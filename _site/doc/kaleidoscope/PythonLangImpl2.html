
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Kaleidoscope: Chapter 2</title>
    
    <meta name="author" content="">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/themes/twitter/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">
    <link href="/stylesheets/pygment_trac.css" rel="stylesheet" type="text/css">
    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
  </head>

  <body>

    <div class="navbar">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">llvm-py Documentation</a>
          <ul class="nav">
            
            
            


  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/pages.html">Pages</a></li>
      	
      
    
  



          </ul>
        </div>
      </div>
    </div>

    <div class="container">

      <div class="content">
        
<div class="page-header">
  <h1>Kaleidoscope: Chapter 2 </h1>
</div>

<div class="row">
  <div class="span12">
    <h1 id='implementing_a_parser_and_ast'>Implementing a Parser and AST</h1>

<p>Written by <a href='mailto:sabre@nondot.org'>Chris Lattner</a> and <a href='http://max99x.com'>Max Shawabkeh</a></p>

<p><strong>Chapter 2</strong></p>
<div class='maruku_toc'><ul style='list-style: none;'><li><a href='#implementing_a_parser_and_ast'>Implementing a Parser and AST</a></li><li><a href='#intro'>Introduction</a></li><li><a href='#ast'>The Abstract Syntax Tree (AST)</a></li><li><a href='#parserbasics'>Parser Basics</a></li><li><a href='#parserprimexprs'>Basic Expression Parsing</a></li><li><a href='#parserbinops'>Binary Expression Parsing</a></li><li><a href='#parsertop'>Parsing the Rest</a></li><li><a href='#driver'>The Driver</a></li><li><a href='#conclusions'>Conclusions</a></li><li><a href='#code'>Full Code Listing</a></li></ul></div>
<p><strong><a href='PythonLangImpl3.html'>Chapter 3: Code generation to LLVM IR</a></strong></p>

<h1 id='intro'>Introduction</h1>

<p>Welcome to Chapter 2 of the <a href='http://www.llvm.org/docs/tutorial/index.html'>Implementing a language with LLVM</a> tutorial. This chapter shows you how to use the lexer, built in <a href='PythonLangImpl1.html'>Chapter 1</a>, to build a full <a href='http://en.wikipedia.org/wiki/Parsing'>parser</a> for our Kaleidoscope language. Once we have a parser, we&#8217;ll define and build an <a href='http://en.wikipedia.org/wiki/Abstract_syntax_tree'>Abstract Syntax Tree</a> (AST).</p>

<p>The parser we will build uses a combination of <a href='http://en.wikipedia.org/wiki/Recursive_descent_parser'>Recursive Descent Parsing</a> and <a href='http://en.wikipedia.org/wiki/Operator-precedence_parser'>Operator-Precedence Parsing</a> to parse the Kaleidoscope language (the latter for binary expressions and the former for everything else). Before we get to parsing though, lets talk about the output of the parser: the Abstract Syntax Tree.</p>
<hr />
<h1 id='ast'>The Abstract Syntax Tree (AST)</h1>

<p>The AST for a program captures its behavior in such a way that it is easy for later stages of the compiler (e.g. code generation) to interpret. We basically want one object for each construct in the language, and the AST should closely model the language. In Kaleidoscope, we have expressions, a prototype, and a function object. We&#8217;ll start with expressions first:</p>
<div class='highlight'><pre><code class='python'><span class='c'># Base class for all expression nodes.</span>
<span class='k'>class</span> <span class='nc'>ExpressionNode</span><span class='p'>(</span><span class='nb'>object</span><span class='p'>):</span>
  <span class='k'>pass</span>

<span class='c'># Expression class for numeric literals like &quot;1.0&quot;.</span>
<span class='k'>class</span> <span class='nc'>NumberExpressionNode</span><span class='p'>(</span><span class='n'>ExpressionNode</span><span class='p'>):</span>
  <span class='k'>def</span> <span class='nf'>__init__</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>value</span><span class='p'>):</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>value</span> <span class='o'>=</span> <span class='n'>value</span>
</code></pre>
</div>
<p>The code above shows the definition of the base ExpressionNode class and one subclass which we use for numeric literals. The important thing to note about this code is that the NumberExpressionNode class captures the numeric value of the literal as an instance variable. This allows later phases of the compiler to know what the stored numeric value is.</p>

<p>Right now we only create the AST, so there are no useful methods on them. It would be very easy to add a virtual method to pretty print the code, for example. Here are the other expression AST node definitions that we&#8217;ll use in the basic form of the Kaleidoscope language:</p>
<div class='highlight'><pre><code class='python'><span class='c'># Expression class for referencing a variable, like &quot;a&quot;.</span>
<span class='k'>class</span> <span class='nc'>VariableExpressionNode</span><span class='p'>(</span><span class='n'>ExpressionNode</span><span class='p'>):</span>
  <span class='k'>def</span> <span class='nf'>__init__</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>name</span><span class='p'>):</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>name</span> <span class='o'>=</span> <span class='n'>name</span>

<span class='c'># Expression class for a binary operator.</span>
<span class='k'>class</span> <span class='nc'>BinaryOperatorExpressionNode</span><span class='p'>(</span><span class='n'>ExpressionNode</span><span class='p'>):</span>
  <span class='k'>def</span> <span class='nf'>__init__</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>operator</span><span class='p'>,</span> <span class='n'>left</span><span class='p'>,</span> <span class='n'>right</span><span class='p'>):</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>operator</span> <span class='o'>=</span> <span class='n'>operator</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>left</span> <span class='o'>=</span> <span class='n'>left</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>right</span> <span class='o'>=</span> <span class='n'>right</span>

<span class='c'># Expression class for function calls.</span>
<span class='k'>class</span> <span class='nc'>CallExpressionNode</span><span class='p'>(</span><span class='n'>ExpressionNode</span><span class='p'>):</span>
  <span class='k'>def</span> <span class='nf'>__init__</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>callee</span><span class='p'>,</span> <span class='n'>args</span><span class='p'>):</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>callee</span> <span class='o'>=</span> <span class='n'>callee</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>args</span> <span class='o'>=</span> <span class='n'>args</span>
</code></pre>
</div>
<p>This is all (intentionally) rather straight-forward: variables capture the variable name, binary operators capture their opcode (e.g. &#8217;+&#8217;), and calls capture a function name as well as a list of any argument expressions. One thing that is nice about our AST is that it captures the language features without talking about the syntax of the language. Note that there is no discussion about precedence of binary operators, lexical structure, etc.</p>

<p>For our basic language, these are all of the expression nodes we&#8217;ll define. Because it doesn&#8217;t have conditional control flow, it isn&#8217;t Turing-complete; we&#8217;ll fix that in a later installment. The two things we need next are a way to talk about the interface to a function, and a way to talk about functions themselves:</p>
<div class='highlight'><pre><code class='python'><span class='c'># This class represents the &quot;prototype&quot; for a function, which captures its name,</span>
<span class='c'># and its argument names (thus implicitly the number of arguments the function</span>
<span class='c'># takes).</span>
<span class='k'>class</span> <span class='nc'>PrototypeNode</span><span class='p'>(</span><span class='nb'>object</span><span class='p'>):</span>
  <span class='k'>def</span> <span class='nf'>__init__</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>name</span><span class='p'>,</span> <span class='n'>args</span><span class='p'>):</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>name</span> <span class='o'>=</span> <span class='n'>name</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>args</span> <span class='o'>=</span> <span class='n'>args</span>

<span class='c'># This class represents a function definition itself.</span>
<span class='k'>class</span> <span class='nc'>FunctionNode</span><span class='p'>(</span><span class='nb'>object</span><span class='p'>):</span>
  <span class='k'>def</span> <span class='nf'>__init__</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>prototype</span><span class='p'>,</span> <span class='n'>body</span><span class='p'>):</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>prototype</span> <span class='o'>=</span> <span class='n'>prototype</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>body</span> <span class='o'>=</span> <span class='n'>body</span>
</code></pre>
</div>
<p>In Kaleidoscope, functions are typed with just a count of their arguments. Since all values are double precision floating point, the type of each argument doesn&#8217;t need to be stored anywhere. In a more aggressive and realistic language, the <code>ExpressionNode</code> class would probably have a type field.</p>

<p>With this scaffolding, we can now talk about parsing expressions and function bodies in Kaleidoscope.</p>
<hr />
<h1 id='parserbasics'>Parser Basics</h1>

<p>Now that we have an AST to build, we need to define the parser code to build it. The idea here is that we want to parse something like <code>x + y</code> (which is returned as three tokens by the lexer) into an AST that could be generated with calls like this:</p>
<div class='highlight'><pre><code class='python'>  <span class='n'>x</span> <span class='o'>=</span> <span class='n'>VariableExpressionNode</span><span class='p'>(</span><span class='s'>&#39;x&#39;</span><span class='p'>)</span>
  <span class='n'>y</span> <span class='o'>=</span> <span class='n'>VariableExpressionNode</span><span class='p'>(</span><span class='s'>&#39;y&#39;</span><span class='p'>)</span>
  <span class='n'>result</span> <span class='o'>=</span> <span class='n'>BinaryOperatorExpressionNode</span><span class='p'>(</span><span class='s'>&#39;+&#39;</span><span class='p'>,</span> <span class='n'>x</span><span class='p'>,</span> <span class='n'>y</span><span class='p'>)</span>
</code></pre>
</div>
<p>In order to do this, we&#8217;ll start by defining a lightweight <code>Parser</code> class with some basic helper routines:</p>
<div class='highlight'><pre><code class='python'><span class='k'>class</span> <span class='nc'>Parser</span><span class='p'>(</span><span class='nb'>object</span><span class='p'>):</span>

  <span class='k'>def</span> <span class='nf'>__init__</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>tokens</span><span class='p'>,</span> <span class='n'>binop_precedence</span><span class='p'>):</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>tokens</span> <span class='o'>=</span> <span class='n'>tokens</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>binop_precedence</span> <span class='o'>=</span> <span class='n'>binop_precedence</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>

  <span class='c'># Provide a simple token buffer. Parser.current is the current token the</span>
  <span class='c'># parser is looking at. Parser.Next() reads another token from the lexer and</span>
  <span class='c'># updates Parser.current with its results.</span>
  <span class='k'>def</span> <span class='nf'>Next</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>):</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span> <span class='o'>=</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>tokens</span><span class='o'>.</span><span class='n'>next</span><span class='p'>()</span>
</code></pre>
</div>
<p>This implements a simple token buffer around the lexer. This allows us to look one token ahead at what the lexer is returning. Every function in our parser will assume that <code>self.current</code> is the current token that needs to be parsed. Note that the first token is read as soon as the parser is instantiated. Let us ignore the <code>binop_precedence</code> parameter for now. It will be explained when we start <a href='#parserbinops'>parsing binary operators</a>.</p>

<p>With these basic helper functions, we can implement the first piece of our grammar: numeric literals.</p>
<hr />
<h1 id='parserprimexprs'>Basic Expression Parsing</h1>

<p>We start with numeric literals, because they are the simplest to process. For each production in our grammar, we&#8217;ll define a function which parses that production. For numeric literals, we have:</p>
<div class='highlight'><pre><code class='python'>  <span class='c'># numberexpr ::= number</span>
  <span class='k'>def</span> <span class='nf'>ParseNumberExpr</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>):</span>
    <span class='n'>result</span> <span class='o'>=</span> <span class='n'>NumberExpressionNode</span><span class='p'>(</span><span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span><span class='o'>.</span><span class='n'>value</span><span class='p'>)</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>  <span class='c'># consume the number.</span>
    <span class='k'>return</span> <span class='n'>result</span>
</code></pre>
</div>
<p>This method is very simple: it expects to be called when the current token is a <code>NumberToken</code>. It takes the current number value, creates a <code>NumberExpressionNode</code>, advances to the next token, and finally returns.</p>

<p>There are some interesting aspects to this. The most important one is that this routine eats all of the tokens that correspond to the production and returns the lexer buffer with the next token (which is not part of the grammar production) ready to go. This is a fairly standard way to go for recursive descent parsers. For a better example, the parenthesis operator is defined like this:</p>
<div class='highlight'><pre><code class='python'>  <span class='c'># parenexpr ::= &#39;(&#39; expression &#39;)&#39;</span>
  <span class='k'>def</span> <span class='nf'>ParseParenExpr</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>):</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>  <span class='c'># eat &#39;(&#39;.</span>

    <span class='n'>contents</span> <span class='o'>=</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>ParseExpression</span><span class='p'>()</span>

    <span class='k'>if</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span> <span class='o'>!=</span> <span class='n'>CharacterToken</span><span class='p'>(</span><span class='s'>&#39;)&#39;</span><span class='p'>):</span>
      <span class='k'>raise</span> <span class='ne'>RuntimeError</span><span class='p'>(</span><span class='s'>&#39;Expected &quot;)&quot;.&#39;</span><span class='p'>)</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>  <span class='c'># eat &#39;)&#39;.</span>

    <span class='k'>return</span> <span class='n'>contents</span>
</code></pre>
</div>
<p>This function illustrates an interesting aspect of the parser. The function uses recursion by calling <code>ParseExpression</code> (we will soon see that <code>ParseExpression</code> can call <code>ParseParenExpr</code>). This is powerful because it allows us to handle recursive grammars, and keeps each production very simple. Note that parentheses do not cause construction of AST nodes themselves. While we could do it this way, the most important role of parentheses are to guide the parser and provide grouping. Once the parser constructs the AST, parentheses are not needed.</p>

<p>The next simple production is for handling variable references and function calls:</p>
<div class='highlight'><pre><code class='python'>  <span class='c'># identifierexpr ::= identifier | identifier &#39;(&#39; expression* &#39;)&#39;</span>
  <span class='k'>def</span> <span class='nf'>ParseIdentifierExpr</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>):</span>
    <span class='n'>identifier_name</span> <span class='o'>=</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span><span class='o'>.</span><span class='n'>name</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>  <span class='c'># eat identifier.</span>

    <span class='k'>if</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span> <span class='o'>!=</span> <span class='n'>CharacterToken</span><span class='p'>(</span><span class='s'>&#39;(&#39;</span><span class='p'>):</span>  <span class='c'># Simple variable reference.</span>
      <span class='k'>return</span> <span class='n'>VariableExpressionNode</span><span class='p'>(</span><span class='n'>identifier_name</span><span class='p'>);</span>

    <span class='c'># Call.</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>  <span class='c'># eat &#39;(&#39;.</span>
    <span class='n'>args</span> <span class='o'>=</span> <span class='p'>[]</span>
    <span class='k'>if</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span> <span class='o'>!=</span> <span class='n'>CharacterToken</span><span class='p'>(</span><span class='s'>&#39;)&#39;</span><span class='p'>):</span>
      <span class='k'>while</span> <span class='bp'>True</span><span class='p'>:</span>
        <span class='n'>args</span><span class='o'>.</span><span class='n'>append</span><span class='p'>(</span><span class='bp'>self</span><span class='o'>.</span><span class='n'>ParseExpression</span><span class='p'>())</span>
        <span class='k'>if</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span> <span class='o'>==</span> <span class='n'>CharacterToken</span><span class='p'>(</span><span class='s'>&#39;)&#39;</span><span class='p'>):</span>
          <span class='k'>break</span>
        <span class='k'>elif</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span> <span class='o'>!=</span> <span class='n'>CharacterToken</span><span class='p'>(</span><span class='s'>&#39;,&#39;</span><span class='p'>):</span>
          <span class='k'>raise</span> <span class='ne'>RuntimeError</span><span class='p'>(</span><span class='s'>&#39;Expected &quot;)&quot; or &quot;,&quot; in argument list.&#39;</span><span class='p'>)</span>
        <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>

    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>  <span class='c'># eat &#39;)&#39;.</span>
    <span class='k'>return</span> <span class='n'>CallExpressionNode</span><span class='p'>(</span><span class='n'>identifier_name</span><span class='p'>,</span> <span class='n'>args</span><span class='p'>)</span>
</code></pre>
</div>
<p>This routine follows the same style as the other routines. It expects to be called if the current token is an <code>IdentifierToken</code>. It also has recursion and error handling. One interesting aspect of this is that it uses <em>look-ahead</em> to determine if the current identifier is a stand alone variable reference or if it is a function call expression. It handles this by checking to see if the token after the identifier is a &#8216;(&#8217; token, constructing either a <code>VariableExpressionNode</code> or <code>CallExpressionNode</code> as appropriate.</p>

<p>Now that we have all of our simple expression-parsing logic in place, we can define a helper function to wrap it together into one entry point. We call this class of expressions &#8220;primary&#8221; expressions, for reasons that will become more clear <a href='PythonLangImpl6.html#unary'>later in the tutorial</a>. In order to parse an arbitrary primary expression, we need to determine what sort of expression it is:</p>
<div class='highlight'><pre><code class='python'>  <span class='c'># primary ::= identifierexpr | numberexpr | parenexpr</span>
  <span class='k'>def</span> <span class='nf'>ParsePrimary</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>):</span>
    <span class='k'>if</span> <span class='nb'>isinstance</span><span class='p'>(</span><span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span><span class='p'>,</span> <span class='n'>IdentifierToken</span><span class='p'>):</span>
      <span class='k'>return</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>ParseIdentifierExpr</span><span class='p'>()</span>
    <span class='k'>elif</span> <span class='nb'>isinstance</span><span class='p'>(</span><span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span><span class='p'>,</span> <span class='n'>NumberToken</span><span class='p'>):</span>
      <span class='k'>return</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>ParseNumberExpr</span><span class='p'>();</span>
    <span class='k'>elif</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span> <span class='o'>==</span> <span class='n'>CharacterToken</span><span class='p'>(</span><span class='s'>&#39;(&#39;</span><span class='p'>):</span>
      <span class='k'>return</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>ParseParenExpr</span><span class='p'>()</span>
    <span class='k'>else</span><span class='p'>:</span>
      <span class='k'>raise</span> <span class='ne'>RuntimeError</span><span class='p'>(</span><span class='s'>&#39;Unknown token when expecting an expression.&#39;</span><span class='p'>)</span>
</code></pre>
</div>
<p>Now that you see the definition of this function, it is more obvious why we can assume the state of <code>Parser.current</code> in the various functions. This uses look-ahead to determine which sort of expression is being inspected, and then parses it with a function call.</p>

<p>Now that basic expressions are handled, we need to handle binary expressions. They are a bit more complex.</p>
<hr />
<h1 id='parserbinops'>Binary Expression Parsing</h1>

<p>Binary expressions are significantly harder to parse because they are often ambiguous. For example, when given the string <code>x+y*z</code>, the parser can choose to parse it as either <code>(x+y)*z</code> or <code>x+(y*z)</code>. With common definitions from mathematics, we expect the later parse, because <code>*</code> (multiplication) has higher <em>precedence</em> than <code>+</code> (addition).</p>

<p>There are many ways to handle this, but an elegant and efficient way is to use <a href='http://en.wikipedia.org/wiki/Operator-precedence_parser'>Operator-Precedence Parsing</a>. This parsing technique uses the precedence of binary operators to guide recursion. To start with, we need a table of precedences. Remember the <code>binop_precedence</code> parameter we passed to the <code>Parser</code> constructor? Now is the time to use it:</p>
<div class='highlight'><pre><code class='python'><span class='k'>def</span> <span class='nf'>main</span><span class='p'>():</span>
  <span class='c'># Install standard binary operators.</span>
  <span class='c'># 1 is lowest possible precedence. 40 is the highest.</span>
  <span class='n'>operator_precedence</span> <span class='o'>=</span> <span class='p'>{</span>
    <span class='s'>&#39;&lt;&#39;</span><span class='p'>:</span> <span class='mi'>10</span><span class='p'>,</span>
    <span class='s'>&#39;+&#39;</span><span class='p'>:</span> <span class='mi'>20</span><span class='p'>,</span>
    <span class='s'>&#39;-&#39;</span><span class='p'>:</span> <span class='mi'>20</span><span class='p'>,</span>
    <span class='s'>&#39;*&#39;</span><span class='p'>:</span> <span class='mi'>40</span>
  <span class='p'>}</span>

  <span class='c'># Run the main `interpreter loop`.</span>
  <span class='k'>while</span> <span class='bp'>True</span><span class='p'>:</span>

    <span class='o'>...</span>

    <span class='n'>parser</span> <span class='o'>=</span> <span class='n'>Parser</span><span class='p'>(</span><span class='n'>Tokenize</span><span class='p'>(</span><span class='n'>raw</span><span class='p'>),</span> <span class='n'>operator_precedence</span><span class='p'>)</span>
</code></pre>
</div>
<p>For the basic form of Kaleidoscope, we will only support 4 binary operators (this can obviously be extended by you, our brave and intrepid reader). Having a dictionary makes it easy to add new operators and makes it clear that the algorithm doesn&#8217;t depend on the specific operators involved, but it would be easy enough to eliminate the map and hardcode the comparisons.</p>

<p>We also define a helper function to get the precedence of the current token, or -1 if the token is not a binary operator:</p>
<div class='highlight'><pre><code class='python'>  <span class='c'># Gets the precedence of the current token, or -1 if the token is not a binary</span>
  <span class='c'># operator.</span>
  <span class='k'>def</span> <span class='nf'>GetCurrentTokenPrecedence</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>):</span>
    <span class='k'>if</span> <span class='nb'>isinstance</span><span class='p'>(</span><span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span><span class='p'>,</span> <span class='n'>CharacterToken</span><span class='p'>):</span>
      <span class='k'>return</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>binop_precedence</span><span class='o'>.</span><span class='n'>get</span><span class='p'>(</span><span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span><span class='o'>.</span><span class='n'>char</span><span class='p'>,</span> <span class='o'>-</span><span class='mi'>1</span><span class='p'>)</span>
    <span class='k'>else</span><span class='p'>:</span>
      <span class='k'>return</span> <span class='o'>-</span><span class='mi'>1</span>
</code></pre>
</div>
<p>With the helper above defined, we can now start parsing binary expressions. The basic idea of operator precedence parsing is to break down an expression with potentially ambiguous binary operators into pieces. Consider, for example, the expression <code>a+b+(c+d)*e*f+g</code>. Operator precedence parsing considers this as a stream of primary expressions separated by binary operators. As such, it will first parse the leading primary expression <code>a</code>, then it will see the pairs <code>[+, b] [+, (c+d)] [*, e] [*, f] and [+, g]</code>. Note that because parentheses are primary expressions, the binary expression parser doesn&#8217;t need to worry about nested subexpressions like (c+d) at all.</p>

<p>To start, an expression is a primary expression potentially followed by a sequence of <code>[binop,primaryexpr]</code> pairs:</p>
<div class='highlight'><pre><code class='python'>  <span class='c'># expression ::= primary binoprhs</span>
  <span class='k'>def</span> <span class='nf'>ParseExpression</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>):</span>
    <span class='n'>left</span> <span class='o'>=</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>ParsePrimary</span><span class='p'>()</span>
    <span class='k'>return</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>ParseBinOpRHS</span><span class='p'>(</span><span class='n'>left</span><span class='p'>,</span> <span class='mi'>0</span><span class='p'>)</span>
</code></pre>
</div>
<p><code>ParseBinOpRHS</code> is the function that parses the sequence of pairs for us. It takes a precedence and a pointer to an expression for the part that has been parsed so far. Note that <code>x</code> is a perfectly valid expression: As such, <code>binoprhs</code> is allowed to be empty, in which case it returns the expression that is passed into it. In our example above, the code passes the expression for <code>a</code> into <code>ParseBinOpRHS</code> and the current token is <code>+</code>.</p>

<p>The precedence value passed into <code>ParseBinOpRHS</code> indicates the * minimal operator precedence* that the function is allowed to eat. For example, if the current pair stream is <code>[+, x]</code> and <code>ParseBinOpRHS</code> is passed in a precedence of 40, it will not consume any tokens (because the precedence of &#8217;+&#8217; is only 20). With this in mind, <code>ParseBinOpRHS</code> starts with:</p>
<div class='highlight'><pre><code class='python'>  <span class='c'># binoprhs ::= (operator primary)*</span>
  <span class='k'>def</span> <span class='nf'>ParseBinOpRHS</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>left</span><span class='p'>,</span> <span class='n'>left_precedence</span><span class='p'>):</span>
    <span class='c'># If this is a binary operator, find its precedence.</span>
    <span class='k'>while</span> <span class='bp'>True</span><span class='p'>:</span>
      <span class='n'>precedence</span> <span class='o'>=</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>GetCurrentTokenPrecedence</span><span class='p'>()</span>

      <span class='c'># If this is a binary operator that binds at least as tightly as the</span>
      <span class='c'># current one, consume it; otherwise we are done.</span>
      <span class='k'>if</span> <span class='n'>precedence</span> <span class='o'>&lt;</span> <span class='n'>left_precedence</span><span class='p'>:</span>
        <span class='k'>return</span> <span class='n'>left</span>
</code></pre>
</div>
<p>This code gets the precedence of the current token and checks to see if if is too low. Because we defined invalid tokens to have a precedence of -1, this check implicitly knows that the pair-stream ends when the token stream runs out of binary operators. If this check succeeds, we know that the token is a binary operator and that it will be included in this expression:</p>
<div class='highlight'><pre><code class='python'>      <span class='n'>binary_operator</span> <span class='o'>=</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span><span class='o'>.</span><span class='n'>char</span>
      <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>  <span class='c'># eat the operator.</span>

      <span class='c'># Parse the primary expression after the binary operator.</span>
      <span class='n'>right</span> <span class='o'>=</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>ParsePrimary</span><span class='p'>()</span>
</code></pre>
</div>
<p>As such, this code eats (and remembers) the binary operator and then parses the primary expression that follows. This builds up the whole pair, the first of which is <code>[+, b]</code> for the running example.</p>

<p>Now that we parsed the left-hand side of an expression and one pair of the RHS sequence, we have to decide which way the expression associates. In particular, we could have <code>(a+b) binop unparsed</code> or <code>a + (b binop unparsed)</code>. To determine this, we look ahead at <code>binop</code> to determine its precedence and compare it to BinOp&#8217;s precedence (which is &#8217;+&#8217; in this case):</p>
<div class='highlight'><pre><code class='python'>      <span class='c'># If binary_operator binds less tightly with right than the operator after</span>
      <span class='c'># right, let the pending operator take right as its left.</span>
      <span class='n'>next_precedence</span> <span class='o'>=</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>GetCurrentTokenPrecedence</span><span class='p'>()</span>
      <span class='k'>if</span> <span class='n'>precedence</span> <span class='o'>&lt;</span> <span class='n'>next_precedence</span><span class='p'>:</span>
</code></pre>
</div>
<p>If the precedence of the binop to the right of <code>RHS</code> is lower or equal to the precedence of our current operator, then we know that the parentheses associate as <code>(a+b) binop ...</code>. In our example, the current operator is <code>+</code> and the next operator is <code>+</code>, we know that they have the same precedence. In this case we&#8217;ll create the AST node for <code>a+b</code>, and then continue parsing:</p>
<div class='highlight'><pre><code class='python'>      <span class='k'>if</span> <span class='n'>precedence</span> <span class='o'>&lt;</span> <span class='n'>next_precedence</span><span class='p'>:</span>
        <span class='o'>...</span> <span class='k'>if</span> <span class='n'>body</span> <span class='n'>omitted</span> <span class='o'>...</span>

      <span class='c'># Merge left/right.</span>
      <span class='n'>left</span> <span class='o'>=</span> <span class='n'>BinaryOperatorExpressionNode</span><span class='p'>(</span><span class='n'>binary_operator</span><span class='p'>,</span> <span class='n'>left</span><span class='p'>,</span> <span class='n'>right</span><span class='p'>);</span>
</code></pre>
</div>
<p>In our example above, this will turn <code>a+b+</code> into <code>(a+b)</code> and execute the next iteration of the loop, with <code>+</code> as the current token. The code above will eat, remember, and parse <code>(c+d)</code> as the primary expression, which makes the current pair equal to <code>[+, (c+d)]</code>. It will then evaluate the &#8216;if&#8217; conditional above with <code>*</code> as the binop to the right of the primary. In this case, the precedence of <code>*</code> is higher than the precedence of <code>+</code> so the if condition will be entered.</p>

<p>The critical question left here is <code>how can the if condition parse the right
hand side in full</code>? In particular, to build the AST correctly for our example, it needs to get all of <code> ( c + d ) * e * f</code> as the RHS expression variable. The code to do this is surprisingly simple (code from the above two blocks duplicated for context):</p>
<div class='highlight'><pre><code class='python'>      <span class='c'># If binary_operator binds less tightly with right than the operator after</span>
      <span class='c'># right, let the pending operator take right as its left.</span>
      <span class='n'>next_precedence</span> <span class='o'>=</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>GetCurrentTokenPrecedence</span><span class='p'>()</span>
      <span class='k'>if</span> <span class='n'>precedence</span> <span class='o'>&lt;</span> <span class='n'>next_precedence</span><span class='p'>:</span>
        <span class='n'>right</span> <span class='o'>=</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>ParseBinOpRHS</span><span class='p'>(</span><span class='n'>right</span><span class='p'>,</span> <span class='n'>precedence</span> <span class='o'>+</span> <span class='mi'>1</span><span class='p'>)</span>

      <span class='c'># Merge left/right.</span>
      <span class='n'>left</span> <span class='o'>=</span> <span class='n'>BinaryOperatorExpressionNode</span><span class='p'>(</span><span class='n'>binary_operator</span><span class='p'>,</span> <span class='n'>left</span><span class='p'>,</span> <span class='n'>right</span><span class='p'>)</span>
</code></pre>
</div>
<p>At this point, we know that the binary operator to the RHS of our primary has higher precedence than the binop we are currently parsing. As such, we know that any sequence of pairs whose operators are all higher precedence than <code>+</code> should be parsed together and returned as <code>RHS</code>. To do this, we recursively invoke the <code>ParseBinOpRHS</code> function specifying <code>precedence + 1</code> as the minimum precedence required for it to continue. In our example above, this will cause it to return the AST node for <code>(c+d)*e*f</code> as RHS, which is then set as the RHS of the &#8217;+&#8217; expression.</p>

<p>Finally, on the next iteration of the while loop, the <code>+g</code> piece is parsed and added to the AST. With this little bit of code (11 non-trivial lines), we correctly handle fully general binary expression parsing in a very elegant way. This was a whirlwind tour of this code, and it is somewhat subtle. I recommend running through it with a few tough examples to see how it works.</p>

<p>This wraps up handling of expressions. At this point, we can point the parser at an arbitrary token stream and build an expression from it, stopping at the first token that is not part of the expression. Next up we need to handle function definitions, etc.</p>
<hr />
<h1 id='parsertop'>Parsing the Rest</h1>

<p>The next thing missing is handling of function prototypes. In Kaleidoscope, these are used both for &#8216;extern&#8217; function declarations as well as function body definitions. The code to do this is straight-forward and not very interesting (once you&#8217;ve survived expressions):</p>
<div class='highlight'><pre><code class='python'>  <span class='c'># prototype ::= id &#39;(&#39; id* &#39;)&#39;</span>
  <span class='k'>def</span> <span class='nf'>ParsePrototype</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>):</span>
    <span class='k'>if</span> <span class='ow'>not</span> <span class='nb'>isinstance</span><span class='p'>(</span><span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span><span class='p'>,</span> <span class='n'>IdentifierToken</span><span class='p'>):</span>
      <span class='k'>raise</span> <span class='ne'>RuntimeError</span><span class='p'>(</span><span class='s'>&#39;Expected function name in prototype.&#39;</span><span class='p'>)</span>

    <span class='n'>function_name</span> <span class='o'>=</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span><span class='o'>.</span><span class='n'>name</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>  <span class='c'># eat function name.</span>

    <span class='k'>if</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span> <span class='o'>!=</span> <span class='n'>CharacterToken</span><span class='p'>(</span><span class='s'>&#39;(&#39;</span><span class='p'>):</span>
      <span class='k'>raise</span> <span class='ne'>RuntimeError</span><span class='p'>(</span><span class='s'>&#39;Expected &quot;(&quot; in prototype.&#39;</span><span class='p'>)</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>  <span class='c'># eat &#39;(&#39;.</span>

    <span class='n'>arg_names</span> <span class='o'>=</span> <span class='p'>[]</span>
    <span class='k'>while</span> <span class='nb'>isinstance</span><span class='p'>(</span><span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span><span class='p'>,</span> <span class='n'>IdentifierToken</span><span class='p'>):</span>
      <span class='n'>arg_names</span><span class='o'>.</span><span class='n'>append</span><span class='p'>(</span><span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span><span class='o'>.</span><span class='n'>name</span><span class='p'>)</span>
      <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>

    <span class='k'>if</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span> <span class='o'>!=</span> <span class='n'>CharacterToken</span><span class='p'>(</span><span class='s'>&#39;)&#39;</span><span class='p'>):</span>
      <span class='k'>raise</span> <span class='ne'>RuntimeError</span><span class='p'>(</span><span class='s'>&#39;Expected &quot;)&quot; in prototype.&#39;</span><span class='p'>)</span>

    <span class='c'># Success.</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>  <span class='c'># eat &#39;)&#39;.</span>

    <span class='k'>return</span> <span class='n'>PrototypeNode</span><span class='p'>(</span><span class='n'>function_name</span><span class='p'>,</span> <span class='n'>arg_names</span><span class='p'>)</span>
</code></pre>
</div>
<p>Given this, a function definition is very simple, just a prototype plus an expression to implement the body:</p>
<div class='highlight'><pre><code class='python'>  <span class='c'># definition ::= &#39;def&#39; prototype expression</span>
  <span class='k'>def</span> <span class='nf'>ParseDefinition</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>):</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>  <span class='c'># eat def.</span>
    <span class='n'>proto</span> <span class='o'>=</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>ParsePrototype</span><span class='p'>()</span>
    <span class='n'>body</span> <span class='o'>=</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>ParseExpression</span><span class='p'>()</span>
    <span class='k'>return</span> <span class='n'>FunctionNode</span><span class='p'>(</span><span class='n'>proto</span><span class='p'>,</span> <span class='n'>body</span><span class='p'>)</span>
</code></pre>
</div>
<p>In addition, we support &#8216;extern&#8217; to declare functions like &#8216;sin&#8217; and &#8216;cos&#8217; as well as to support forward declaration of user functions. These &#8216;extern&#8217;s are just prototypes with no body:</p>
<div class='highlight'><pre><code class='python'>  <span class='c'># external ::= &#39;extern&#39; prototype</span>
  <span class='k'>def</span> <span class='nf'>ParseExtern</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>):</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>  <span class='c'># eat extern.</span>
    <span class='k'>return</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>ParsePrototype</span><span class='p'>()</span>
</code></pre>
</div>
<p>Finally, we&#8217;ll also let the user type in arbitrary top-level expressions and evaluate them on the fly. We will handle this by defining anonymous nullary (zero argument) functions for them:</p>
<div class='highlight'><pre><code class='python'>  <span class='c'># toplevelexpr ::= expression</span>
  <span class='k'>def</span> <span class='nf'>ParseTopLevelExpr</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>):</span>
    <span class='n'>proto</span> <span class='o'>=</span> <span class='n'>PrototypeNode</span><span class='p'>(</span><span class='s'>&#39;&#39;</span><span class='p'>,</span> <span class='p'>[])</span>
    <span class='k'>return</span> <span class='n'>FunctionNode</span><span class='p'>(</span><span class='n'>proto</span><span class='p'>,</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>ParseExpression</span><span class='p'>())</span>
</code></pre>
</div>
<p>Now that we have all the pieces, let&#8217;s build a little driver that will let us actually <em>execute</em> this code we&#8217;ve built!</p>
<hr />
<h1 id='driver'>The Driver</h1>

<p>The driver for this simply invokes all of the parsing pieces with a top-level dispatch loop. There isn&#8217;t much interesting here, so I&#8217;ll just include the top-level loop. See <a href='#code'>below</a> for full code.</p>
<div class='highlight'><pre><code class='python'>  <span class='c'># Run the main &quot;interpreter loop&quot;.</span>
  <span class='k'>while</span> <span class='bp'>True</span><span class='p'>:</span>
    <span class='k'>print</span> <span class='s'>&#39;ready&gt;&#39;</span><span class='p'>,</span>
    <span class='k'>try</span><span class='p'>:</span>
      <span class='n'>raw</span> <span class='o'>=</span> <span class='nb'>raw_input</span><span class='p'>()</span>
    <span class='k'>except</span> <span class='ne'>KeyboardInterrupt</span><span class='p'>:</span>
      <span class='k'>return</span>

    <span class='n'>parser</span> <span class='o'>=</span> <span class='n'>Parser</span><span class='p'>(</span><span class='n'>Tokenize</span><span class='p'>(</span><span class='n'>raw</span><span class='p'>),</span> <span class='n'>operator_precedence</span><span class='p'>)</span>
    <span class='k'>while</span> <span class='bp'>True</span><span class='p'>:</span>
      <span class='c'># top ::= definition | external | expression | EOF</span>
      <span class='k'>if</span> <span class='nb'>isinstance</span><span class='p'>(</span><span class='n'>parser</span><span class='o'>.</span><span class='n'>current</span><span class='p'>,</span> <span class='n'>EOFToken</span><span class='p'>):</span>
        <span class='k'>break</span>
      <span class='k'>if</span> <span class='nb'>isinstance</span><span class='p'>(</span><span class='n'>parser</span><span class='o'>.</span><span class='n'>current</span><span class='p'>,</span> <span class='n'>DefToken</span><span class='p'>):</span>
        <span class='n'>parser</span><span class='o'>.</span><span class='n'>HandleDefinition</span><span class='p'>()</span>
      <span class='k'>elif</span> <span class='nb'>isinstance</span><span class='p'>(</span><span class='n'>parser</span><span class='o'>.</span><span class='n'>current</span><span class='p'>,</span> <span class='n'>ExternToken</span><span class='p'>):</span>
        <span class='n'>parser</span><span class='o'>.</span><span class='n'>HandleExtern</span><span class='p'>()</span>
      <span class='k'>else</span><span class='p'>:</span>
        <span class='n'>parser</span><span class='o'>.</span><span class='n'>HandleTopLevelExpression</span><span class='p'>()</span>
</code></pre>
</div>
<p>Here we create a new <code>Parser</code> for each line read, and try to parse out all the expressions, declarations and definitions in the line. We also allow the user to quit using Ctrl+C.</p>
<hr />
<h1 id='conclusions'>Conclusions</h1>

<p>With just under 330 lines of commented code (200 lines of non-comment, non-blank code), we fully defined our minimal language, including a lexer, parser, and AST builder. With this done, the executable will validate Kaleidoscope code and tell us if it is grammatically invalid. For example, here is a sample interaction:</p>
<div class='highlight'><pre><code class='python'><span class='err'>$</span> <span class='n'>python</span> <span class='n'>kaleidoscope</span><span class='o'>.</span><span class='n'>py</span>
<span class='n'>ready</span><span class='o'>&gt;</span> <span class='k'>def</span> <span class='nf'>foo</span><span class='p'>(</span><span class='n'>x</span> <span class='n'>y</span><span class='p'>)</span> <span class='n'>x</span><span class='o'>+</span><span class='n'>foo</span><span class='p'>(</span><span class='n'>y</span><span class='p'>,</span> <span class='mf'>4.0</span><span class='p'>)</span>
<span class='n'>Parsed</span> <span class='n'>a</span> <span class='n'>function</span> <span class='n'>definition</span><span class='o'>.</span>
<span class='n'>ready</span><span class='o'>&gt;</span> <span class='k'>def</span> <span class='nf'>foo</span><span class='p'>(</span><span class='n'>x</span> <span class='n'>y</span><span class='p'>)</span> <span class='n'>x</span><span class='o'>+</span><span class='n'>y</span> <span class='n'>y</span>
<span class='n'>Parsed</span> <span class='n'>a</span> <span class='n'>function</span> <span class='n'>definition</span><span class='o'>.</span>
<span class='n'>Parsed</span> <span class='n'>a</span> <span class='n'>top</span><span class='o'>-</span><span class='n'>level</span> <span class='n'>expression</span><span class='o'>.</span>
<span class='n'>ready</span><span class='o'>&gt;</span> <span class='k'>def</span> <span class='nf'>foo</span><span class='p'>(</span><span class='n'>x</span> <span class='n'>y</span><span class='p'>)</span> <span class='n'>x</span><span class='o'>+</span><span class='n'>y</span> <span class='p'>)</span>
<span class='n'>Parsed</span> <span class='n'>a</span> <span class='n'>function</span> <span class='n'>definition</span><span class='o'>.</span>
<span class='n'>Error</span><span class='p'>:</span> <span class='n'>Unknown</span> <span class='n'>token</span> <span class='n'>when</span> <span class='n'>expecting</span> <span class='n'>an</span> <span class='n'>expression</span><span class='o'>.</span>
<span class='n'>ready</span><span class='o'>&gt;</span> <span class='n'>extern</span> <span class='n'>sin</span><span class='p'>(</span><span class='n'>a</span><span class='p'>);</span>
<span class='n'>Parsed</span> <span class='n'>an</span> <span class='n'>extern</span><span class='o'>.</span>
<span class='n'>ready</span><span class='o'>&gt;</span> <span class='o'>^</span><span class='n'>C</span>
<span class='err'>$</span>
</code></pre>
</div>
<p>There is a lot of room for extension here. You can define new AST nodes, extend the language in many ways, etc. In the <a href='PythonLangImpl3.html'>next installment</a>, we will describe how to generate LLVM Intermediate Representation (IR) from the AST.</p>
<hr />
<h1 id='code'>Full Code Listing</h1>

<p>Here is the complete code listing for this and the previous chapter. Note that it is fully self-contained: you don&#8217;t need LLVM or any external libraries at all for this.</p>
<div class='highlight'><pre><code class='python'><span class='c'>#!/usr/bin/env python</span>

<span class='kn'>import</span> <span class='nn'>re</span>

<span class='c'>################################################################################</span>
<span class='c'>## Lexer</span>
<span class='c'>################################################################################</span>

<span class='c'># The lexer yields one of these types for each token.</span>
<span class='k'>class</span> <span class='nc'>EOFToken</span><span class='p'>(</span><span class='nb'>object</span><span class='p'>):</span>
  <span class='k'>pass</span>

<span class='k'>class</span> <span class='nc'>DefToken</span><span class='p'>(</span><span class='nb'>object</span><span class='p'>):</span>
  <span class='k'>pass</span>

<span class='k'>class</span> <span class='nc'>ExternToken</span><span class='p'>(</span><span class='nb'>object</span><span class='p'>):</span>
  <span class='k'>pass</span>

<span class='k'>class</span> <span class='nc'>IdentifierToken</span><span class='p'>(</span><span class='nb'>object</span><span class='p'>):</span>
  <span class='k'>def</span> <span class='nf'>__init__</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>name</span><span class='p'>):</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>name</span> <span class='o'>=</span> <span class='n'>name</span>

<span class='k'>class</span> <span class='nc'>NumberToken</span><span class='p'>(</span><span class='nb'>object</span><span class='p'>):</span>
  <span class='k'>def</span> <span class='nf'>__init__</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>value</span><span class='p'>):</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>value</span> <span class='o'>=</span> <span class='n'>value</span>

<span class='k'>class</span> <span class='nc'>CharacterToken</span><span class='p'>(</span><span class='nb'>object</span><span class='p'>):</span>
  <span class='k'>def</span> <span class='nf'>__init__</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>char</span><span class='p'>):</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>char</span> <span class='o'>=</span> <span class='n'>char</span>
  <span class='k'>def</span> <span class='nf'>__eq__</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>other</span><span class='p'>):</span>
    <span class='k'>return</span> <span class='nb'>isinstance</span><span class='p'>(</span><span class='n'>other</span><span class='p'>,</span> <span class='n'>CharacterToken</span><span class='p'>)</span> <span class='ow'>and</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>char</span> <span class='o'>==</span> <span class='n'>other</span><span class='o'>.</span><span class='n'>char</span>
  <span class='k'>def</span> <span class='nf'>__ne__</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>other</span><span class='p'>):</span> <span class='k'>return</span> <span class='ow'>not</span> <span class='bp'>self</span> <span class='o'>==</span> <span class='n'>other</span>

<span class='c'># Regular expressions that tokens and comments of our language.</span>
<span class='n'>REGEX_NUMBER</span> <span class='o'>=</span> <span class='n'>re</span><span class='o'>.</span><span class='n'>compile</span><span class='p'>(</span><span class='s'>&#39;[0-9]+(?:\.[0-9]+)?&#39;</span><span class='p'>)</span>
<span class='n'>REGEX_IDENTIFIER</span> <span class='o'>=</span> <span class='n'>re</span><span class='o'>.</span><span class='n'>compile</span><span class='p'>(</span><span class='s'>&#39;[a-zA-Z][a-zA-Z0-9]*&#39;</span><span class='p'>)</span>
<span class='n'>REGEX_COMMENT</span> <span class='o'>=</span> <span class='n'>re</span><span class='o'>.</span><span class='n'>compile</span><span class='p'>(</span><span class='s'>&#39;#.*&#39;</span><span class='p'>)</span>

<span class='k'>def</span> <span class='nf'>Tokenize</span><span class='p'>(</span><span class='n'>string</span><span class='p'>):</span>
  <span class='k'>while</span> <span class='n'>string</span><span class='p'>:</span>
    <span class='c'># Skip whitespace.</span>
    <span class='k'>if</span> <span class='n'>string</span><span class='p'>[</span><span class='mi'>0</span><span class='p'>]</span><span class='o'>.</span><span class='n'>isspace</span><span class='p'>():</span>
      <span class='n'>string</span> <span class='o'>=</span> <span class='n'>string</span><span class='p'>[</span><span class='mi'>1</span><span class='p'>:]</span>
      <span class='k'>continue</span>

    <span class='c'># Run regexes.</span>
    <span class='n'>comment_match</span> <span class='o'>=</span> <span class='n'>REGEX_COMMENT</span><span class='o'>.</span><span class='n'>match</span><span class='p'>(</span><span class='n'>string</span><span class='p'>)</span>
    <span class='n'>number_match</span> <span class='o'>=</span> <span class='n'>REGEX_NUMBER</span><span class='o'>.</span><span class='n'>match</span><span class='p'>(</span><span class='n'>string</span><span class='p'>)</span>
    <span class='n'>identifier_match</span> <span class='o'>=</span> <span class='n'>REGEX_IDENTIFIER</span><span class='o'>.</span><span class='n'>match</span><span class='p'>(</span><span class='n'>string</span><span class='p'>)</span>

    <span class='c'># Check if any of the regexes matched and yield the appropriate result.</span>
    <span class='k'>if</span> <span class='n'>comment_match</span><span class='p'>:</span>
      <span class='n'>comment</span> <span class='o'>=</span> <span class='n'>comment_match</span><span class='o'>.</span><span class='n'>group</span><span class='p'>(</span><span class='mi'>0</span><span class='p'>)</span>
      <span class='n'>string</span> <span class='o'>=</span> <span class='n'>string</span><span class='p'>[</span><span class='nb'>len</span><span class='p'>(</span><span class='n'>comment</span><span class='p'>):]</span>
    <span class='k'>elif</span> <span class='n'>number_match</span><span class='p'>:</span>
      <span class='n'>number</span> <span class='o'>=</span> <span class='n'>number_match</span><span class='o'>.</span><span class='n'>group</span><span class='p'>(</span><span class='mi'>0</span><span class='p'>)</span>
      <span class='k'>yield</span> <span class='n'>NumberToken</span><span class='p'>(</span><span class='nb'>float</span><span class='p'>(</span><span class='n'>number</span><span class='p'>))</span>
      <span class='n'>string</span> <span class='o'>=</span> <span class='n'>string</span><span class='p'>[</span><span class='nb'>len</span><span class='p'>(</span><span class='n'>number</span><span class='p'>):]</span>
    <span class='k'>elif</span> <span class='n'>identifier_match</span><span class='p'>:</span>
      <span class='n'>identifier</span> <span class='o'>=</span> <span class='n'>identifier_match</span><span class='o'>.</span><span class='n'>group</span><span class='p'>(</span><span class='mi'>0</span><span class='p'>)</span>
      <span class='c'># Check if we matched a keyword.</span>
      <span class='k'>if</span> <span class='n'>identifier</span> <span class='o'>==</span> <span class='s'>&#39;def&#39;</span><span class='p'>:</span>
        <span class='k'>yield</span> <span class='n'>DefToken</span><span class='p'>()</span>
      <span class='k'>elif</span> <span class='n'>identifier</span> <span class='o'>==</span> <span class='s'>&#39;extern&#39;</span><span class='p'>:</span>
        <span class='k'>yield</span> <span class='n'>ExternToken</span><span class='p'>()</span>
      <span class='k'>else</span><span class='p'>:</span>
        <span class='k'>yield</span> <span class='n'>IdentifierToken</span><span class='p'>(</span><span class='n'>identifier</span><span class='p'>)</span>
      <span class='n'>string</span> <span class='o'>=</span> <span class='n'>string</span><span class='p'>[</span><span class='nb'>len</span><span class='p'>(</span><span class='n'>identifier</span><span class='p'>):]</span>
    <span class='k'>else</span><span class='p'>:</span>
      <span class='c'># Yield the ASCII value of the unknown character.</span>
      <span class='k'>yield</span> <span class='n'>CharacterToken</span><span class='p'>(</span><span class='n'>string</span><span class='p'>[</span><span class='mi'>0</span><span class='p'>])</span>
      <span class='n'>string</span> <span class='o'>=</span> <span class='n'>string</span><span class='p'>[</span><span class='mi'>1</span><span class='p'>:]</span>

  <span class='k'>yield</span> <span class='n'>EOFToken</span><span class='p'>()</span>

<span class='c'>################################################################################</span>
<span class='c'>## Abstract Syntax Tree (aka Parse Tree)</span>
<span class='c'>################################################################################</span>

<span class='c'># Base class for all expression nodes.</span>
<span class='k'>class</span> <span class='nc'>ExpressionNode</span><span class='p'>(</span><span class='nb'>object</span><span class='p'>):</span>
  <span class='k'>pass</span>

<span class='c'># Expression class for numeric literals like &quot;1.0&quot;.</span>
<span class='k'>class</span> <span class='nc'>NumberExpressionNode</span><span class='p'>(</span><span class='n'>ExpressionNode</span><span class='p'>):</span>
  <span class='k'>def</span> <span class='nf'>__init__</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>value</span><span class='p'>):</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>value</span> <span class='o'>=</span> <span class='n'>value</span>

<span class='c'># Expression class for referencing a variable, like &quot;a&quot;.</span>
<span class='k'>class</span> <span class='nc'>VariableExpressionNode</span><span class='p'>(</span><span class='n'>ExpressionNode</span><span class='p'>):</span>
  <span class='k'>def</span> <span class='nf'>__init__</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>name</span><span class='p'>):</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>name</span> <span class='o'>=</span> <span class='n'>name</span>

<span class='c'># Expression class for a binary operator.</span>
<span class='k'>class</span> <span class='nc'>BinaryOperatorExpressionNode</span><span class='p'>(</span><span class='n'>ExpressionNode</span><span class='p'>):</span>
  <span class='k'>def</span> <span class='nf'>__init__</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>operator</span><span class='p'>,</span> <span class='n'>left</span><span class='p'>,</span> <span class='n'>right</span><span class='p'>):</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>operator</span> <span class='o'>=</span> <span class='n'>operator</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>left</span> <span class='o'>=</span> <span class='n'>left</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>right</span> <span class='o'>=</span> <span class='n'>right</span>

<span class='c'># Expression class for function calls.</span>
<span class='k'>class</span> <span class='nc'>CallExpressionNode</span><span class='p'>(</span><span class='n'>ExpressionNode</span><span class='p'>):</span>
  <span class='k'>def</span> <span class='nf'>__init__</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>callee</span><span class='p'>,</span> <span class='n'>args</span><span class='p'>):</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>callee</span> <span class='o'>=</span> <span class='n'>callee</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>args</span> <span class='o'>=</span> <span class='n'>args</span>

<span class='c'># This class represents the &quot;prototype&quot; for a function, which captures its name,</span>
<span class='c'># and its argument names (thus implicitly the number of arguments the function</span>
<span class='c'># takes).</span>
<span class='k'>class</span> <span class='nc'>PrototypeNode</span><span class='p'>(</span><span class='nb'>object</span><span class='p'>):</span>
  <span class='k'>def</span> <span class='nf'>__init__</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>name</span><span class='p'>,</span> <span class='n'>args</span><span class='p'>):</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>name</span> <span class='o'>=</span> <span class='n'>name</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>args</span> <span class='o'>=</span> <span class='n'>args</span>

<span class='c'># This class represents a function definition itself.</span>
<span class='k'>class</span> <span class='nc'>FunctionNode</span><span class='p'>(</span><span class='nb'>object</span><span class='p'>):</span>
  <span class='k'>def</span> <span class='nf'>__init__</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>prototype</span><span class='p'>,</span> <span class='n'>body</span><span class='p'>):</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>prototype</span> <span class='o'>=</span> <span class='n'>prototype</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>body</span> <span class='o'>=</span> <span class='n'>body</span>


<span class='c'>################################################################################</span>
<span class='c'>## Parser</span>
<span class='c'>################################################################################</span>

<span class='k'>class</span> <span class='nc'>Parser</span><span class='p'>(</span><span class='nb'>object</span><span class='p'>):</span>

  <span class='k'>def</span> <span class='nf'>__init__</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>tokens</span><span class='p'>,</span> <span class='n'>binop_precedence</span><span class='p'>):</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>tokens</span> <span class='o'>=</span> <span class='n'>tokens</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>binop_precedence</span> <span class='o'>=</span> <span class='n'>binop_precedence</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>

  <span class='c'># Provide a simple token buffer. Parser.current is the current token the</span>
  <span class='c'># parser is looking at. Parser.Next() reads another token from the lexer and</span>
  <span class='c'># updates Parser.current with its results.</span>
  <span class='k'>def</span> <span class='nf'>Next</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>):</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span> <span class='o'>=</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>tokens</span><span class='o'>.</span><span class='n'>next</span><span class='p'>()</span>

  <span class='c'># Gets the precedence of the current token, or -1 if the token is not a binary</span>
  <span class='c'># operator.</span>
  <span class='k'>def</span> <span class='nf'>GetCurrentTokenPrecedence</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>):</span>
    <span class='k'>if</span> <span class='nb'>isinstance</span><span class='p'>(</span><span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span><span class='p'>,</span> <span class='n'>CharacterToken</span><span class='p'>):</span>
      <span class='k'>return</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>binop_precedence</span><span class='o'>.</span><span class='n'>get</span><span class='p'>(</span><span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span><span class='o'>.</span><span class='n'>char</span><span class='p'>,</span> <span class='o'>-</span><span class='mi'>1</span><span class='p'>)</span>
    <span class='k'>else</span><span class='p'>:</span>
      <span class='k'>return</span> <span class='o'>-</span><span class='mi'>1</span>

  <span class='c'># identifierexpr ::= identifier | identifier &#39;(&#39; expression* &#39;)&#39;</span>
  <span class='k'>def</span> <span class='nf'>ParseIdentifierExpr</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>):</span>
    <span class='n'>identifier_name</span> <span class='o'>=</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span><span class='o'>.</span><span class='n'>name</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>  <span class='c'># eat identifier.</span>

    <span class='k'>if</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span> <span class='o'>!=</span> <span class='n'>CharacterToken</span><span class='p'>(</span><span class='s'>&#39;(&#39;</span><span class='p'>):</span>  <span class='c'># Simple variable reference.</span>
      <span class='k'>return</span> <span class='n'>VariableExpressionNode</span><span class='p'>(</span><span class='n'>identifier_name</span><span class='p'>)</span>

    <span class='c'># Call.</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>  <span class='c'># eat &#39;(&#39;.</span>
    <span class='n'>args</span> <span class='o'>=</span> <span class='p'>[]</span>
    <span class='k'>if</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span> <span class='o'>!=</span> <span class='n'>CharacterToken</span><span class='p'>(</span><span class='s'>&#39;)&#39;</span><span class='p'>):</span>
      <span class='k'>while</span> <span class='bp'>True</span><span class='p'>:</span>
        <span class='n'>args</span><span class='o'>.</span><span class='n'>append</span><span class='p'>(</span><span class='bp'>self</span><span class='o'>.</span><span class='n'>ParseExpression</span><span class='p'>())</span>
        <span class='k'>if</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span> <span class='o'>==</span> <span class='n'>CharacterToken</span><span class='p'>(</span><span class='s'>&#39;)&#39;</span><span class='p'>):</span>
          <span class='k'>break</span>
        <span class='k'>elif</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span> <span class='o'>!=</span> <span class='n'>CharacterToken</span><span class='p'>(</span><span class='s'>&#39;,&#39;</span><span class='p'>):</span>
          <span class='k'>raise</span> <span class='ne'>RuntimeError</span><span class='p'>(</span><span class='s'>&#39;Expected &quot;)&quot; or &quot;,&quot; in argument list.&#39;</span><span class='p'>)</span>
        <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>

    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>  <span class='c'># eat &#39;)&#39;.</span>
    <span class='k'>return</span> <span class='n'>CallExpressionNode</span><span class='p'>(</span><span class='n'>identifier_name</span><span class='p'>,</span> <span class='n'>args</span><span class='p'>)</span>

  <span class='c'># numberexpr ::= number</span>
  <span class='k'>def</span> <span class='nf'>ParseNumberExpr</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>):</span>
    <span class='n'>result</span> <span class='o'>=</span> <span class='n'>NumberExpressionNode</span><span class='p'>(</span><span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span><span class='o'>.</span><span class='n'>value</span><span class='p'>)</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>  <span class='c'># consume the number.</span>
    <span class='k'>return</span> <span class='n'>result</span>

  <span class='c'># parenexpr ::= &#39;(&#39; expression &#39;)&#39;</span>
  <span class='k'>def</span> <span class='nf'>ParseParenExpr</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>):</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>  <span class='c'># eat &#39;(&#39;.</span>

    <span class='n'>contents</span> <span class='o'>=</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>ParseExpression</span><span class='p'>()</span>

    <span class='k'>if</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span> <span class='o'>!=</span> <span class='n'>CharacterToken</span><span class='p'>(</span><span class='s'>&#39;)&#39;</span><span class='p'>):</span>
      <span class='k'>raise</span> <span class='ne'>RuntimeError</span><span class='p'>(</span><span class='s'>&#39;Expected &quot;)&quot;.&#39;</span><span class='p'>)</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>  <span class='c'># eat &#39;)&#39;.</span>

    <span class='k'>return</span> <span class='n'>contents</span>

  <span class='c'># primary ::= identifierexpr | numberexpr | parenexpr</span>
  <span class='k'>def</span> <span class='nf'>ParsePrimary</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>):</span>
    <span class='k'>if</span> <span class='nb'>isinstance</span><span class='p'>(</span><span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span><span class='p'>,</span> <span class='n'>IdentifierToken</span><span class='p'>):</span>
      <span class='k'>return</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>ParseIdentifierExpr</span><span class='p'>()</span>
    <span class='k'>elif</span> <span class='nb'>isinstance</span><span class='p'>(</span><span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span><span class='p'>,</span> <span class='n'>NumberToken</span><span class='p'>):</span>
      <span class='k'>return</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>ParseNumberExpr</span><span class='p'>()</span>
    <span class='k'>elif</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span> <span class='o'>==</span> <span class='n'>CharacterToken</span><span class='p'>(</span><span class='s'>&#39;(&#39;</span><span class='p'>):</span>
      <span class='k'>return</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>ParseParenExpr</span><span class='p'>()</span>
    <span class='k'>else</span><span class='p'>:</span>
      <span class='k'>raise</span> <span class='ne'>RuntimeError</span><span class='p'>(</span><span class='s'>&#39;Unknown token when expecting an expression.&#39;</span><span class='p'>)</span>

  <span class='c'># binoprhs ::= (operator primary)*</span>
  <span class='k'>def</span> <span class='nf'>ParseBinOpRHS</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>left</span><span class='p'>,</span> <span class='n'>left_precedence</span><span class='p'>):</span>
    <span class='c'># If this is a binary operator, find its precedence.</span>
    <span class='k'>while</span> <span class='bp'>True</span><span class='p'>:</span>
      <span class='n'>precedence</span> <span class='o'>=</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>GetCurrentTokenPrecedence</span><span class='p'>()</span>

      <span class='c'># If this is a binary operator that binds at least as tightly as the</span>
      <span class='c'># current one, consume it; otherwise we are done.</span>
      <span class='k'>if</span> <span class='n'>precedence</span> <span class='o'>&lt;</span> <span class='n'>left_precedence</span><span class='p'>:</span>
        <span class='k'>return</span> <span class='n'>left</span>

      <span class='n'>binary_operator</span> <span class='o'>=</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span><span class='o'>.</span><span class='n'>char</span>
      <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>  <span class='c'># eat the operator.</span>

      <span class='c'># Parse the primary expression after the binary operator.</span>
      <span class='n'>right</span> <span class='o'>=</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>ParsePrimary</span><span class='p'>()</span>

      <span class='c'># If binary_operator binds less tightly with right than the operator after</span>
      <span class='c'># right, let the pending operator take right as its left.</span>
      <span class='n'>next_precedence</span> <span class='o'>=</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>GetCurrentTokenPrecedence</span><span class='p'>()</span>
      <span class='k'>if</span> <span class='n'>precedence</span> <span class='o'>&lt;</span> <span class='n'>next_precedence</span><span class='p'>:</span>
        <span class='n'>right</span> <span class='o'>=</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>ParseBinOpRHS</span><span class='p'>(</span><span class='n'>right</span><span class='p'>,</span> <span class='n'>precedence</span> <span class='o'>+</span> <span class='mi'>1</span><span class='p'>)</span>

      <span class='c'># Merge left/right.</span>
      <span class='n'>left</span> <span class='o'>=</span> <span class='n'>BinaryOperatorExpressionNode</span><span class='p'>(</span><span class='n'>binary_operator</span><span class='p'>,</span> <span class='n'>left</span><span class='p'>,</span> <span class='n'>right</span><span class='p'>)</span>

  <span class='c'># expression ::= primary binoprhs</span>
  <span class='k'>def</span> <span class='nf'>ParseExpression</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>):</span>
    <span class='n'>left</span> <span class='o'>=</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>ParsePrimary</span><span class='p'>()</span>
    <span class='k'>return</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>ParseBinOpRHS</span><span class='p'>(</span><span class='n'>left</span><span class='p'>,</span> <span class='mi'>0</span><span class='p'>)</span>

  <span class='c'># prototype ::= id &#39;(&#39; id* &#39;)&#39;</span>
  <span class='k'>def</span> <span class='nf'>ParsePrototype</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>):</span>
    <span class='k'>if</span> <span class='ow'>not</span> <span class='nb'>isinstance</span><span class='p'>(</span><span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span><span class='p'>,</span> <span class='n'>IdentifierToken</span><span class='p'>):</span>
      <span class='k'>raise</span> <span class='ne'>RuntimeError</span><span class='p'>(</span><span class='s'>&#39;Expected function name in prototype.&#39;</span><span class='p'>)</span>

    <span class='n'>function_name</span> <span class='o'>=</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span><span class='o'>.</span><span class='n'>name</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>  <span class='c'># eat function name.</span>

    <span class='k'>if</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span> <span class='o'>!=</span> <span class='n'>CharacterToken</span><span class='p'>(</span><span class='s'>&#39;(&#39;</span><span class='p'>):</span>
      <span class='k'>raise</span> <span class='ne'>RuntimeError</span><span class='p'>(</span><span class='s'>&#39;Expected &quot;(&quot; in prototype.&#39;</span><span class='p'>)</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>  <span class='c'># eat &#39;(&#39;.</span>

    <span class='n'>arg_names</span> <span class='o'>=</span> <span class='p'>[]</span>
    <span class='k'>while</span> <span class='nb'>isinstance</span><span class='p'>(</span><span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span><span class='p'>,</span> <span class='n'>IdentifierToken</span><span class='p'>):</span>
      <span class='n'>arg_names</span><span class='o'>.</span><span class='n'>append</span><span class='p'>(</span><span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span><span class='o'>.</span><span class='n'>name</span><span class='p'>)</span>
      <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>

    <span class='k'>if</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>current</span> <span class='o'>!=</span> <span class='n'>CharacterToken</span><span class='p'>(</span><span class='s'>&#39;)&#39;</span><span class='p'>):</span>
      <span class='k'>raise</span> <span class='ne'>RuntimeError</span><span class='p'>(</span><span class='s'>&#39;Expected &quot;)&quot; in prototype.&#39;</span><span class='p'>)</span>

    <span class='c'># Success.</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>  <span class='c'># eat &#39;)&#39;.</span>

    <span class='k'>return</span> <span class='n'>PrototypeNode</span><span class='p'>(</span><span class='n'>function_name</span><span class='p'>,</span> <span class='n'>arg_names</span><span class='p'>)</span>

  <span class='c'># definition ::= &#39;def&#39; prototype expression</span>
  <span class='k'>def</span> <span class='nf'>ParseDefinition</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>):</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>  <span class='c'># eat def.</span>
    <span class='n'>proto</span> <span class='o'>=</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>ParsePrototype</span><span class='p'>()</span>
    <span class='n'>body</span> <span class='o'>=</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>ParseExpression</span><span class='p'>()</span>
    <span class='k'>return</span> <span class='n'>FunctionNode</span><span class='p'>(</span><span class='n'>proto</span><span class='p'>,</span> <span class='n'>body</span><span class='p'>)</span>

  <span class='c'># toplevelexpr ::= expression</span>
  <span class='k'>def</span> <span class='nf'>ParseTopLevelExpr</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>):</span>
    <span class='n'>proto</span> <span class='o'>=</span> <span class='n'>PrototypeNode</span><span class='p'>(</span><span class='s'>&#39;&#39;</span><span class='p'>,</span> <span class='p'>[])</span>
    <span class='k'>return</span> <span class='n'>FunctionNode</span><span class='p'>(</span><span class='n'>proto</span><span class='p'>,</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>ParseExpression</span><span class='p'>())</span>

  <span class='c'># external ::= &#39;extern&#39; prototype</span>
  <span class='k'>def</span> <span class='nf'>ParseExtern</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>):</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span>  <span class='c'># eat extern.</span>
    <span class='k'>return</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>ParsePrototype</span><span class='p'>()</span>

  <span class='c'># Top-Level parsing</span>
  <span class='k'>def</span> <span class='nf'>HandleDefinition</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>):</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Handle</span><span class='p'>(</span><span class='bp'>self</span><span class='o'>.</span><span class='n'>ParseDefinition</span><span class='p'>,</span> <span class='s'>&#39;Parsed a function definition.&#39;</span><span class='p'>)</span>

  <span class='k'>def</span> <span class='nf'>HandleExtern</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>):</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Handle</span><span class='p'>(</span><span class='bp'>self</span><span class='o'>.</span><span class='n'>ParseExtern</span><span class='p'>,</span> <span class='s'>&#39;Parsed an extern.&#39;</span><span class='p'>)</span>

  <span class='k'>def</span> <span class='nf'>HandleTopLevelExpression</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>):</span>
    <span class='bp'>self</span><span class='o'>.</span><span class='n'>Handle</span><span class='p'>(</span><span class='bp'>self</span><span class='o'>.</span><span class='n'>ParseTopLevelExpr</span><span class='p'>,</span> <span class='s'>&#39;Parsed a top-level expression.&#39;</span><span class='p'>)</span>

  <span class='k'>def</span> <span class='nf'>Handle</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>function</span><span class='p'>,</span> <span class='n'>message</span><span class='p'>):</span>
    <span class='k'>try</span><span class='p'>:</span>
      <span class='n'>function</span><span class='p'>()</span>
      <span class='k'>print</span> <span class='n'>message</span>
    <span class='k'>except</span> <span class='ne'>Exception</span><span class='p'>,</span> <span class='n'>e</span><span class='p'>:</span>
      <span class='k'>print</span> <span class='s'>&#39;Error:&#39;</span><span class='p'>,</span> <span class='n'>e</span>
      <span class='k'>try</span><span class='p'>:</span>
        <span class='bp'>self</span><span class='o'>.</span><span class='n'>Next</span><span class='p'>()</span> <span class='c'># Skip for error recovery.</span>
      <span class='k'>except</span><span class='p'>:</span>
        <span class='k'>pass</span>

<span class='c'>################################################################################</span>
<span class='c'>## Main driver code.</span>
<span class='c'>################################################################################</span>

<span class='k'>def</span> <span class='nf'>main</span><span class='p'>():</span>
  <span class='c'># Install standard binary operators.</span>
  <span class='c'># 1 is lowest possible precedence. 40 is the highest.</span>
  <span class='n'>operator_precedence</span> <span class='o'>=</span> <span class='p'>{</span>
    <span class='s'>&#39;&lt;&#39;</span><span class='p'>:</span> <span class='mi'>10</span><span class='p'>,</span>
    <span class='s'>&#39;+&#39;</span><span class='p'>:</span> <span class='mi'>20</span><span class='p'>,</span>
    <span class='s'>&#39;-&#39;</span><span class='p'>:</span> <span class='mi'>20</span><span class='p'>,</span>
    <span class='s'>&#39;*&#39;</span><span class='p'>:</span> <span class='mi'>40</span>
  <span class='p'>}</span>

  <span class='c'># Run the main &quot;interpreter loop&quot;.</span>
  <span class='k'>while</span> <span class='bp'>True</span><span class='p'>:</span>
    <span class='k'>print</span> <span class='s'>&#39;ready&gt;&#39;</span><span class='p'>,</span>
    <span class='k'>try</span><span class='p'>:</span>
      <span class='n'>raw</span> <span class='o'>=</span> <span class='nb'>raw_input</span><span class='p'>()</span>
    <span class='k'>except</span> <span class='ne'>KeyboardInterrupt</span><span class='p'>:</span>
      <span class='k'>return</span>

    <span class='n'>parser</span> <span class='o'>=</span> <span class='n'>Parser</span><span class='p'>(</span><span class='n'>Tokenize</span><span class='p'>(</span><span class='n'>raw</span><span class='p'>),</span> <span class='n'>operator_precedence</span><span class='p'>)</span>
    <span class='k'>while</span> <span class='bp'>True</span><span class='p'>:</span>
      <span class='c'># top ::= definition | external | expression | EOF</span>
      <span class='k'>if</span> <span class='nb'>isinstance</span><span class='p'>(</span><span class='n'>parser</span><span class='o'>.</span><span class='n'>current</span><span class='p'>,</span> <span class='n'>EOFToken</span><span class='p'>):</span>
        <span class='k'>break</span>
      <span class='k'>if</span> <span class='nb'>isinstance</span><span class='p'>(</span><span class='n'>parser</span><span class='o'>.</span><span class='n'>current</span><span class='p'>,</span> <span class='n'>DefToken</span><span class='p'>):</span>
        <span class='n'>parser</span><span class='o'>.</span><span class='n'>HandleDefinition</span><span class='p'>()</span>
      <span class='k'>elif</span> <span class='nb'>isinstance</span><span class='p'>(</span><span class='n'>parser</span><span class='o'>.</span><span class='n'>current</span><span class='p'>,</span> <span class='n'>ExternToken</span><span class='p'>):</span>
        <span class='n'>parser</span><span class='o'>.</span><span class='n'>HandleExtern</span><span class='p'>()</span>
      <span class='k'>else</span><span class='p'>:</span>
        <span class='n'>parser</span><span class='o'>.</span><span class='n'>HandleTopLevelExpression</span><span class='p'>()</span>

<span class='k'>if</span> <span class='n'>__name__</span> <span class='o'>==</span> <span class='s'>&#39;__main__&#39;</span><span class='p'>:</span>
  <span class='n'>main</span><span class='p'>()</span>
</code></pre>
</div><hr />
<p><strong><a href='PythonLangImpl3.html'>Next: Implementing Code Generation to LLVM IR</a></strong></p>
  </div>
</div>


      </div>

      <footer>
        <p>&copy;  2012
          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
        </p>
      </footer>

    </div> <!-- /container -->

    
  </body>
</html>

