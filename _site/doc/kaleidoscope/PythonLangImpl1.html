
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Kaleidoscope: Chapter 1</title>
    
    <meta name="author" content="">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/themes/twitter/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">
    <link href="/stylesheets/pygment_trac.css" rel="stylesheet" type="text/css">
    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
  </head>

  <body>

    <div class="navbar">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">llvm-py Documentation</a>
          <ul class="nav">
            
            
            


  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/pages.html">Pages</a></li>
      	
      
    
  



          </ul>
        </div>
      </div>
    </div>

    <div class="container">

      <div class="content">
        
<div class="page-header">
  <h1>Kaleidoscope: Chapter 1 </h1>
</div>

<div class="row">
  <div class="span12">
    <h1 id='tutorial_introduction_and_the_lexer'>Tutorial Introduction and the Lexer</h1>

<p>Written by <a href='mailto:sabre@nondot.org'>Chris Lattner</a> and <a href='http://max99x.com'>Max Shawabkeh</a></p>

<p><strong>Chapter 1</strong></p>
<div class='maruku_toc'><ul style='list-style: none;'><li><a href='#tutorial_introduction_and_the_lexer'>Tutorial Introduction and the Lexer</a></li><li><a href='#introduction'>Introduction</a></li><li><a href='#language'>The Basic Language</a></li><li><a href='#lexer'>The Lexer</a></li></ul></div>
<p><a href='PythonLangImpl2.html'><strong>Chapter 2: Implementing a Parser and AST</strong></a></p>

<h1 id='introduction'>Introduction</h1>

<p>Welcome to the &#8220;Implementing a language with LLVM&#8221; tutorial. This tutorial runs through the implementation of a simple language, showing how fun and easy it can be. This tutorial will get you up and started as well as help to build a framework you can extend to other languages. The code in this tutorial can also be used as a playground to hack on other LLVM specific things.</p>

<p>It is useful to point out ahead of time that this tutorial is really about teaching compiler techniques and LLVM specifically, <em>not</em> about teaching modern and sane software engineering principles. In practice, this means that we&#8217;ll take a number of shortcuts to simplify the exposition. If you dig in and use the code as a basis for future projects, fixing its deficiencies shouldn&#8217;t be hard.</p>

<p>We&#8217;ve tried to put this tutorial together in a way that makes chapters easy to skip over if you are already familiar with or are uninterested in the various pieces. The structure of the tutorial is:</p>

<ul>
<li>
<p><strong><a href='#language'>Chapter 1</a>: Introduction to the Kaleidoscope language, and the definition of its Lexer</strong> &#8211; This shows where we are going and the basic functionality that we want it to do. In order to make this tutorial maximally understandable and hackable, we choose to implement everything in Python instead of using lexer and parser generators. LLVM obviously works just fine with such tools, feel free to use one if you prefer.</p>
</li>

<li>
<p><strong><a href='PythonLangImpl2.html'>Chapter 2</a>: Implementing a Parser and AST</strong> &#8211; With the lexer in place, we can talk about parsing techniques and basic AST construction. This tutorial describes recursive descent parsing and operator precedence parsing. Nothing in Chapters 1 or 2 is LLVM-specific, the code doesn&#8217;t even import the LLVM modules at this point. :)</p>
</li>

<li>
<p><strong><a href='PythonLangImpl3.html'>Chapter 3</a>: Code generation to LLVM IR</strong> &#8211; With the AST ready, we can show off how easy generation of LLVM IR really is.</p>
</li>

<li>
<p><strong><a href='PythonLangImpl4.html'>Chapter 4</a>: Adding JIT and Optimizer support</strong> &#8211; Because a lot of people are interested in using LLVM as a JIT, we&#8217;ll dive right into it and show you the 3 lines it takes to add JIT support. LLVM is also useful in many other ways, but this is one simple and &#8220;sexy&#8221; way to shows off its power. :)</p>
</li>

<li>
<p><strong><a href='PythonLangImpl5.html'>Chapter 5</a>: Extending the Language: Control Flow</strong> &#8211; With the language up and running, we show how to extend it with control flow operations (if/then/else and a &#8216;for&#8217; loop). This gives us a chance to talk about simple SSA construction and control flow.</p>
</li>

<li>
<p><strong><a href='PythonLangImpl6.html'>Chapter 6</a>: Extending the Language: User-defined Operators</strong> &#8211; This is a silly but fun chapter that talks about extending the language to let the user program define their own arbitrary unary and binary operators (with assignable precedence!). This lets us build a significant piece of the &#8220;language&#8221; as library routines.</p>
</li>

<li>
<p><strong><a href='PythonLangImpl7.html'>Chapter 7</a>: Extending the Language: Mutable Variables</strong> &#8211; This chapter talks about adding user-defined local variables along with an assignment operator. The interesting part about this is how easy and trivial it is to construct SSA form in LLVM: no, LLVM does <em>not</em> require your front-end to construct SSA form!</p>
</li>

<li>
<p><strong><a href='PythonLangImpl8.html'>Chapter 8</a>: Conclusion and other useful LLVM tidbits</strong> &#8211; This chapter wraps up the series by talking about potential ways to extend the language, but also includes a bunch of pointers to info about &#8220;special topics&#8221; like adding garbage collection support, exceptions, debugging, support for &#8220;spaghetti stacks&#8221;, and a bunch of other tips and tricks.</p>
</li>
</ul>

<p>By the end of the tutorial, we&#8217;ll have written a bit less than 540 lines of non-comment, non-blank, lines of code. With this small amount of code, we&#8217;ll have built up a very reasonable compiler for a non-trivial language including a hand-written lexer, parser, AST, as well as code generation support with a JIT compiler. While other systems may have interesting &#8220;hello world&#8221; tutorials, I think the breadth of this tutorial is a great testament to the strengths of LLVM and why you should consider it if you&#8217;re interested in language or compiler design.</p>

<p>A note about this tutorial: we expect you to extend the language and play with it on your own. Take the code and go crazy hacking away at it, compilers don&#8217;t need to be scary creatures - it can be a lot of fun to play with languages!</p>
<hr />
<h1 id='language'>The Basic Language</h1>

<p>This tutorial will be illustrated with a toy language that we&#8217;ll call &#8221;<a href='http://en.wikipedia.org/wiki/Kaleidoscope'>Kaleidoscope</a>&#8221; (derived from &#8220;meaning beautiful, form, and view&#8221;). Kaleidoscope is a procedural language that allows you to define functions, use conditionals, math, etc. Over the course of the tutorial, we&#8217;ll extend Kaleidoscope to support the if/then/else construct, a for loop, user defined operators, JIT compilation with a simple command line interface, etc.</p>

<p>Because we want to keep things simple, the only datatype in Kaleidoscope is a 64-bit floating point type. As such, all values are implicitly double precision and the language doesn&#8217;t require type declarations. This gives the language a very nice and simple syntax. For example, the following simple example computes <a href='http://en.wikipedia.org/wiki/Fibonacci_number'>Fibonacci numbers</a>:</p>
<div class='highlight'><pre><code class='python'><span class='c'># Compute the x&#39;th fibonacci number.</span>
<span class='k'>def</span> <span class='nf'>fib</span><span class='p'>(</span><span class='n'>x</span><span class='p'>)</span>
  <span class='k'>if</span> <span class='n'>x</span> <span class='o'>&amp;</span><span class='n'>lt</span><span class='p'>;</span> <span class='mi'>3</span> <span class='n'>then</span>
    <span class='mi'>1</span>
  <span class='k'>else</span>
    <span class='n'>fib</span><span class='p'>(</span><span class='n'>x</span><span class='o'>-</span><span class='mi'>1</span><span class='p'>)</span><span class='o'>+</span><span class='n'>fib</span><span class='p'>(</span><span class='n'>x</span><span class='o'>-</span><span class='mi'>2</span><span class='p'>)</span>

<span class='c'># This expression will compute the 40th number.</span>
<span class='n'>fib</span><span class='p'>(</span><span class='mi'>40</span><span class='p'>)</span>
</code></pre>
</div>
<p>We also allow Kaleidoscope to call into standard library functions (the LLVM JIT makes this completely trivial). This means that you can use the &#8216;extern&#8217; keyword to define a function before you use it (this is also useful for mutually recursive functions). For example:</p>
<div class='highlight'><pre><code class='python'><span class='n'>extern</span> <span class='n'>sin</span><span class='p'>(</span><span class='n'>arg</span><span class='p'>);</span>
<span class='n'>extern</span> <span class='n'>cos</span><span class='p'>(</span><span class='n'>arg</span><span class='p'>);</span>
<span class='n'>extern</span> <span class='n'>atan2</span><span class='p'>(</span><span class='n'>arg1</span> <span class='n'>arg2</span><span class='p'>);</span>

<span class='n'>atan2</span><span class='p'>(</span><span class='n'>sin</span><span class='p'>(</span><span class='mf'>0.4</span><span class='p'>),</span> <span class='n'>cos</span><span class='p'>(</span><span class='mi'>42</span><span class='p'>))</span>
</code></pre>
</div>
<p>A more interesting example is included in Chapter 6 where we write a little Kaleidoscope application that <a href='PythonLangImpl6.html#example'>displays</a> a Mandelbrot Set&lt;/a&gt; at various levels of magnification.</p>

<p>Lets dive into the implementation of this language!</p>
<hr />
<h1 id='lexer'>The Lexer</h1>

<p>When it comes to implementing a language, the first thing needed is the ability to process a text file and recognize what it says. The traditional way to do this is to use a <a href='http://en.wikipedia.org/wiki/Lexical_analysis'>lexer</a>&#8221; (aka &#8216;scanner&#8217;) to break the input up into &#8220;tokens&#8221;. Each token returned by the lexer includes a token type and potentially some metadata (e.g. the numeric value of a number). First, we define the possibilities:</p>
<div class='highlight'><pre><code class='python'><span class='c'># The lexer yields one of these types for each token.</span>
<span class='k'>class</span> <span class='nc'>EOFToken</span><span class='p'>(</span><span class='nb'>object</span><span class='p'>):</span>
  <span class='k'>pass</span>

<span class='k'>class</span> <span class='nc'>DefToken</span><span class='p'>(</span><span class='nb'>object</span><span class='p'>):</span>
  <span class='k'>pass</span>

<span class='k'>class</span> <span class='nc'>ExternToken</span><span class='p'>(</span><span class='nb'>object</span><span class='p'>):</span>
  <span class='k'>pass</span>

<span class='k'>class</span> <span class='nc'>IdentifierToken</span><span class='p'>(</span><span class='nb'>object</span><span class='p'>):</span>
  <span class='k'>def</span> <span class='nf'>__init__</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>name</span><span class='p'>):</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>name</span> <span class='o'>=</span> <span class='n'>name</span>

<span class='k'>class</span> <span class='nc'>NumberToken</span><span class='p'>(</span><span class='nb'>object</span><span class='p'>):</span>
  <span class='k'>def</span> <span class='nf'>__init__</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>value</span><span class='p'>):</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>value</span> <span class='o'>=</span> <span class='n'>value</span>

<span class='k'>class</span> <span class='nc'>CharacterToken</span><span class='p'>(</span><span class='nb'>object</span><span class='p'>):</span>
  <span class='k'>def</span> <span class='nf'>__init__</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>char</span><span class='p'>):</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>char</span> <span class='o'>=</span> <span class='n'>char</span>
  <span class='k'>def</span> <span class='nf'>__eq__</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>other</span><span class='p'>):</span>
    <span class='k'>return</span> <span class='nb'>isinstance</span><span class='p'>(</span><span class='n'>other</span><span class='p'>,</span> <span class='n'>CharacterToken</span><span class='p'>)</span> <span class='ow'>and</span> <span class='bp'>self</span><span class='o'>.</span><span class='n'>char</span> <span class='o'>==</span> <span class='n'>other</span><span class='o'>.</span><span class='n'>char</span>
  <span class='k'>def</span> <span class='nf'>__ne__</span><span class='p'>(</span><span class='bp'>self</span><span class='p'>,</span> <span class='n'>other</span><span class='p'>):</span> <span class='k'>return</span> <span class='ow'>not</span> <span class='bp'>self</span> <span class='o'>==</span> <span class='n'>other</span>
</code></pre>
</div>
<p>Each token yielded by our lexer will be of one of the above types. For simple tokens that are always the same, like the &#8220;def&#8221; keyword, the lexer will yield <code>DefToken()</code>&gt;. Identifiers, numbers and characters, on the other hand, have extra data, so when the lexer encounteres the number 123.45, it will emit it as <code>NumberToken(123.45)</code>. An identifier <code>foo</code> will be emitted as <code>IdentifierToken(&#39;foo&#39;)</code>. And finally, an unknown character like &#8217;+&#8217; will be returned as <code>CharacterToken(&#39;+&#39;)</code>. You may notice that we overload the equality and inequality operators for the characters; this will later simplify character comparisons in the parser code.</p>

<p>The actual implementation of the lexer is a single function called <code>Tokenize</code>, which takes a string and <a href='http://docs.python.org/reference/simple_stmts.html#the-yield-statement'>yields</a> tokens. For simplicity, we will use <a href='http://docs.python.org/library/re.html'>regular expressions</a> to parse out the tokens. This is terribly inefficient, but perfectly sufficient for our needs.</p>

<p>First, we define the regular expressions for our tokens. Numbers and strings of digits, optionally followed by a period and another string of digits. Identifiers (and keywords) are alphanumeric string starting with a letter and comments are anything between a hash (<code>#</code>) and the end of the line.</p>
<div class='highlight'><pre><code class='python'><span class='kn'>import</span> <span class='nn'>re</span>

<span class='o'>...</span>

<span class='c'># Regular expressions that tokens and comments of our language.</span>
<span class='n'>REGEX_NUMBER</span> <span class='o'>=</span> <span class='n'>re</span><span class='o'>.</span><span class='n'>compile</span><span class='p'>(</span><span class='s'>&#39;[0-9]+(?:\.[0-9]+)?&#39;</span><span class='p'>)</span>
<span class='n'>REGEX_IDENTIFIER</span> <span class='o'>=</span> <span class='n'>re</span><span class='o'>.</span><span class='n'>compile</span><span class='p'>(</span><span class='s'>&#39;[a-zA-Z][a-zA-Z0-9]*&#39;</span><span class='p'>)</span>
<span class='n'>REGEX_COMMENT</span> <span class='o'>=</span> <span class='n'>re</span><span class='o'>.</span><span class='n'>compile</span><span class='p'>(</span><span class='s'>&#39;#.*&#39;</span><span class='p'>)</span>
</code></pre>
</div>
<p>Next, let&#8217;s start defining the <code>Tokenize</code> function itself. The first thing we need to do is set up a loop that scans the string, while ignoring whitespace between tokens:</p>
<div class='highlight'><pre><code class='python'><span class='k'>def</span> <span class='nf'>Tokenize</span><span class='p'>(</span><span class='n'>string</span><span class='p'>):</span>
  <span class='k'>while</span> <span class='n'>string</span><span class='p'>:</span>
    <span class='c'># Skip whitespace.</span>
    <span class='k'>if</span> <span class='n'>string</span><span class='p'>[</span><span class='mi'>0</span><span class='p'>]</span><span class='o'>.</span><span class='n'>isspace</span><span class='p'>():</span>
      <span class='n'>string</span> <span class='o'>=</span> <span class='n'>string</span><span class='p'>[</span><span class='mi'>1</span><span class='p'>:]</span>
      <span class='k'>continue</span>

    <span class='o'>...</span>
</code></pre>
</div>
<p>Next we want to find out what the next token is. For this we run the regexes we defined above on the remainder of the string. To simplify the rest of the code, we run all three regexes each time. As mentioned above, inefficiencies are ignored for the purpose of this tutorial:</p>
<div class='highlight'><pre><code class='python'>    <span class='c'># Run regexes.</span>
    <span class='n'>comment_match</span> <span class='o'>=</span> <span class='n'>REGEX_COMMENT</span><span class='o'>.</span><span class='n'>match</span><span class='p'>(</span><span class='n'>string</span><span class='p'>)</span>
    <span class='n'>number_match</span> <span class='o'>=</span> <span class='n'>REGEX_NUMBER</span><span class='o'>.</span><span class='n'>match</span><span class='p'>(</span><span class='n'>string</span><span class='p'>)</span>
    <span class='n'>identifier_match</span> <span class='o'>=</span> <span class='n'>REGEX_IDENTIFIER</span><span class='o'>.</span><span class='n'>match</span><span class='p'>(</span><span class='n'>string</span><span class='p'>)</span>
</code></pre>
</div>
<p>Now se check if any of the regexes matched. For comments, we simply ignore the captured match:</p>
<div class='highlight'><pre><code class='python'>    <span class='c'># Check if any of the regexes matched and yield the appropriate result.</span>
    <span class='k'>if</span> <span class='n'>comment_match</span><span class='p'>:</span>
      <span class='n'>comment</span> <span class='o'>=</span> <span class='n'>comment_match</span><span class='o'>.</span><span class='n'>group</span><span class='p'>(</span><span class='mi'>0</span><span class='p'>)</span>
      <span class='n'>string</span> <span class='o'>=</span> <span class='n'>string</span><span class='p'>[</span><span class='nb'>len</span><span class='p'>(</span><span class='n'>comment</span><span class='p'>):]</span>
</code></pre>
</div>
<p>For numbers, we yield the captured match, converted to a float and tagged with the appropriate token type:</p>
<div class='highlight'><pre><code class='python'>    <span class='k'>elif</span> <span class='n'>number_match</span><span class='p'>:</span>
      <span class='n'>number</span> <span class='o'>=</span> <span class='n'>number_match</span><span class='o'>.</span><span class='n'>group</span><span class='p'>(</span><span class='mi'>0</span><span class='p'>)</span>
      <span class='k'>yield</span> <span class='n'>NumberToken</span><span class='p'>(</span><span class='nb'>float</span><span class='p'>(</span><span class='n'>number</span><span class='p'>))</span>
      <span class='n'>string</span> <span class='o'>=</span> <span class='n'>string</span><span class='p'>[</span><span class='nb'>len</span><span class='p'>(</span><span class='n'>number</span><span class='p'>):]</span>
</code></pre>
</div>
<p>The identifier case is a little more complex. We have to check for keywords to decide whether we have captured an identifier or a keyword:</p>
<div class='highlight'><pre><code class='python'>    <span class='k'>elif</span> <span class='n'>identifier_match</span><span class='p'>:</span>
      <span class='n'>identifier</span> <span class='o'>=</span> <span class='n'>identifier_match</span><span class='o'>.</span><span class='n'>group</span><span class='p'>(</span><span class='mi'>0</span><span class='p'>)</span>
      <span class='c'># Check if we matched a keyword.</span>
      <span class='k'>if</span> <span class='n'>identifier</span> <span class='o'>==</span> <span class='s'>&#39;def&#39;</span><span class='p'>:</span>
        <span class='k'>yield</span> <span class='n'>DefToken</span><span class='p'>()</span>
      <span class='k'>elif</span> <span class='n'>identifier</span> <span class='o'>==</span> <span class='s'>&#39;extern&#39;</span><span class='p'>:</span>
        <span class='k'>yield</span> <span class='n'>ExternToken</span><span class='p'>()</span>
      <span class='k'>else</span><span class='p'>:</span>
        <span class='k'>yield</span> <span class='n'>IdentifierToken</span><span class='p'>(</span><span class='n'>identifier</span><span class='p'>)</span>
      <span class='n'>string</span> <span class='o'>=</span> <span class='n'>string</span><span class='p'>[</span><span class='nb'>len</span><span class='p'>(</span><span class='n'>identifier</span><span class='p'>):]</span>
</code></pre>
</div>
<p>Finally, if we haven&#8217;t recognized a comment, a number of an identifier, we yield the current character as an &#8220;unknown character&#8221; token. This is used, for example, for operators like <code>+</code> or <code>*</code>:</p>
<div class='highlight'><pre><code class='python'>    <span class='k'>else</span><span class='p'>:</span>
      <span class='c'># Yield the unknown character.</span>
      <span class='k'>yield</span> <span class='n'>CharacterToken</span><span class='p'>(</span><span class='n'>string</span><span class='p'>[</span><span class='mi'>0</span><span class='p'>])</span>
      <span class='n'>string</span> <span class='o'>=</span> <span class='n'>string</span><span class='p'>[</span><span class='mi'>1</span><span class='p'>:]</span>
</code></pre>
</div>
<p>Once we&#8217;re done with the loop, we return a final end-of-file token:</p>
<div class='highlight'><pre><code class='python'>    <span class='k'>yield</span> <span class='n'>EOFToken</span><span class='p'>()</span>
</code></pre>
</div>
<p>With this, we have the complete lexer for the basic Kaleidoscope language (the <a href='PythonLangImpl2.html#code'>full code listing</a> for the Lexer is available in the <a href='PythonLangImpl2.html'>next chapter</a> of the tutorial). Next we&#8217;ll <a href='PythonLangImpl2.html'>build a simple parser that uses this to build an Abstract Syntax Tree</a>. When we have that, we&#8217;ll include a driver so that you can use the lexer and parser together.</p>
<hr />
<p><strong><a href='PythonLangImpl2.html'>Next: Implementing a Parser and AST</a></strong></p>
  </div>
</div>


      </div>

      <footer>
        <p>&copy;  2012
          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
        </p>
      </footer>

    </div> <!-- /container -->

    
  </body>
</html>

